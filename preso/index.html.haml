---
layout: slideshow/_layout.html.haml
title: Enumerable, and the art of being lazy
...

- content_for[:head] = capture_haml do
  %link{:href => href("custom-styles.css"), :rel => "stylesheet"}/

%section.title

  %h1 Enumerable, and the art of being lazy

  %p Mike Williams, June 2011
  
%section

  %h1 a simple Enumerable

  %pre
    :preserve
    
      class SomeNumbers
  
        # declare one method
        
        def <b>each</b>
          yield 0
          yield 1
          yield 1
          yield 2
          yield 3
          yield 5
          yield 8
        end

        # mix in a bunch more
        
        include <b>Enumerable</b>
        
      end

%section

  %h1 woohoo free stuff!

  %pre
    :preserve

      numbers = SomeNumbers.new

      numbers.to_a              # => [0, 1, 1, 2, 3, 5, 8]

      numbers.take(5)           # => [0, 1, 1, 2, 3]
      numbers.drop(5)           # => [5, 8]

      numbers.max               # => 8

      numbers.collect do |x| 
        x * 2
      end                       # => [0, 2, 2, 4, 6, 10, 16]

      numbers.inject(&:+)       # => 20

%section

  %h1 cf. Unix pipes

  %table.center
    %tr
      %th Enumerable
      %th Unix command
    %tr
      %td
        %code select, reject, grep
      %td
        %code grep, grep -v
    %tr
      %td
        %code collect (map)
      %td
        %code sed, awk, tr
    %tr
      %td
        %code sort, uniq
      %td
        %code sort, uniq
    %tr
      %td
        %code take, drop
      %td
        %code head, tail

  %pre
    :preserve

      cat messages.log | awk '{print $1}' | sort -u | wc -l

      messages.map { |line| line.split[0] }.uniq.size
    
%section

  %h1 an infinite Enumerable

  %pre
    :preserve
    
      class FibonacciSequence
  
        def <b>each</b>
          a = 0
          b = 1
          loop do
            yield a
            a, b = b, a+b
          end
        end

        include <b>Enumerable</b>
        
      end

      irb> FibonacciSequence.new.each { |n| puts n }
      0
      1
      1
      2
      3
      5
      8
      13
      21
      ...

%section

  %h1 infinite problems

  %pre
    :preserve
      
      fib = FibonacciSequence.new
      
      fib.take(5)               # => [0, 1, 1, 2, 3]

      fib.drop(5)               # ... a long wait

      fib.select(&:even?)       # ...

      fib.collect do |x| 
        x * 2
      end                       # ...

  %p Enumerable operations return Array (mostly) and are NOT streamable

%section

  %h1 big problems

  %pre
    :preserve

      # an ActiveRecord example
      scope = Events.where("happened_at < ?", Time.now)
      firehose = scope.to_enum(:find_each)

%section

  %h1 Streaming?

  %p Some operations have to read <u>all</u> the input before producing output, e.g.

  %ul
    %li
      %code min
    %li
      %code max
    %li
      %code sort
    %li
      %code inject

  %p But some <u>could</u> start early, e.g.

  %ul
    %li
      %code select
    %li
      %code reject
    %li
      %code collect
    %li
      %code uniq

%section

  %h1 streamable Enumerable operations

  %pre
    :preserve

      fib.select(&:even?).take(5)     # ... never returns

      fib.selecting(&:even?).take(5)  # => [0, 2, 8, 34, 144]
