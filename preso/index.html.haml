---
layout: slideshow/_layout.html.haml
title: Enumerable, and the art of being lazy
...

- content_for[:head] = capture_haml do
  %link{:href => href("custom-styles.css"), :rel => "stylesheet"}/

%section.title

  %h1 Enumerable, and the art of being lazy

  %p Mike Williams, June 2011
  
%section

  %h1 a simple Enumerable

  %pre
    :preserve
    
      class SomeNumbers
  
        # declare one method
        
        def <b>each</b>
          yield 0
          yield 1
          yield 1
          yield 2
          yield 3
          yield 5
          yield 8
        end

        # mix in a bunch more
        
        include <b>Enumerable</b>
        
      end

%section

  %h1 woohoo free stuff!

  %pre
    :preserve

      numbers = SomeNumbers.new

      numbers.to_a              # => [0, 1, 1, 2, 3, 5, 8]

      numbers.take(5)           # => [0, 1, 1, 2, 3]
      numbers.drop(5)           # => [5, 8]

      numbers.max               # => 8

      numbers.collect do |x| 
        x * 2
      end                       # => [0, 2, 2, 4, 6, 10, 16]

      numbers.inject(&:+)       # => 20

%section

  %h1 cf. Unix pipes

  %table.center
    %tr
      %th Enumerable
      %th Unix command
    %tr
      %td
        %code select/find_all, reject, grep
      %td
        %code grep, grep -v
    %tr
      %td
        %code collect/map
      %td
        %code sed, awk, tr
    %tr
      %td
        %code sort, uniq
      %td
        %code sort, uniq
    %tr
      %td
        %code take, drop
      %td
        %code head, tail

  %pre
    :preserve

      cat messages.log | awk '{print $1}' | sort -u | wc -l

      messages.collect { |line| line.split[0] }.uniq.size

%section

  %h1 some nice properties
  
  %ul.big.sparse

    %li Small, simple operations

    %li Pre-tested

    %li Composable

%section

  %h1 observation:

  %p Some operations have to read <u>all</u> the input before producing output, e.g.

  %ul
    %li
      %code min
    %li
      %code max
    %li
      %code sort
    %li
      %code inject

  %p Some <u>could</u> start early, e.g.

  %ul
    %li
      %code select
    %li
      %code reject
    %li
      %code collect
    %li
      %code uniq

  %p (but they don't)
%section

  %h1 an infinite Enumerable

  %pre
    :preserve
    
      class FibonacciSequence
  
        def <b>each</b>
          a = 0
          b = 1
          loop do
            yield a
            a, b = b, a+b
          end
        end

        include <b>Enumerable</b>
        
      end

      irb> FibonacciSequence.new.each { |n| puts n }
      0
      1
      1
      2
      3
      5
      8
      13
      21
      ...

%section

  %h1 "infinite" problems

  %pre
    :preserve
      
      fib = FibonacciSequence.new
      
      fib.take(5)               # => [0, 1, 1, 2, 3]

      fib.drop(3).take(2)       # ... a long wait

      fib.select(&:even?)       # ... nada

      fib.collect do |x| 
        x * 2
      end                       # ... S.O.L.
  
%section

  %h1 "big" problems

  %pre
    :preserve

      # an ActiveRecord example

      scope = Events.where("happened_at < ?", 1.week.ago)

      event_stream = scope.<b>to_enum</b>(:find_each)
    
      active_sources_last_week = event_stream   \
        .collect { |e| e.actor.name }           \
        .uniq                                   \
        .take(20)                         
      
  %p Problems:
  
  %ul.sparse
    %li generates (using collect, and uniq) a bunch of objects that are never used
    %li might require a lot of memory for temporary storage
  
%section

  %h1 solution: unroll the loops

  %pre
    :preserve

      # BEFORE
      
      active_sources_last_week = event_stream   \
        .collect { |e| e.actor.name }           \
        .uniq                                   \
        .take(20)                         

      # AFTER

      active_sources_last_week = []
      event_stream.each do |e|
        name = e.actor.name
        unless active_sources_last_week.member?(name)
          active_sources_last_week << name
        end
        break if active_sources_last_week.size == 20
      end

  %p Blah. WTF!?
    
%section

  %h1 case in point

  %pre
    :preserve

      # get the first five <u>even</u> Fibonacci numbers

      fib.select(&:even?).take(5)   # ... never returns

      # unrolled
      
      result = []
      
      fib.each do |n|
        result << n if n.even?
        break if result.size == 5
      end
      
      result                        # => [0, 2, 8, 34, 144]

%section

  %h1 getting more functional

  %pre
    :preserve

      # original
      
      fib.select(&:even?).take(5)
      
      # functional
      
      take(select(fib, &:even?), 5)

      # decorative
      
      Taker.new(Selector.new(fib, &:even?), 5)
    
%section

  %h1 decorative Enumerables

  %pre
    :preserve

      class <b>Selector</b>
  
        def initialize(source, &predicate)
          @source = source
          @predicate = predicate
        end
  
        def <b>each</b>
          @source.each do |value|
            yield value if @predicate.call(value)
          end
        end
  
        include Enumerable
  
      end

%section

  %h1 decorative sugar

  %pre
    :preserve

      module Enumerable
  
        def <b>selecting</b>(&predicate)
          Selector.new(self, &predicate)
        end
  
      end

      fib.select(&:even?).take(5)     # ... never returns
      
      fib.<b>selecting</b>(&:even?).take(5)  # => [0, 2, 8, 34, 144]

  %p Tah-dah!

%section

  %h1 Enumerating

  %pre
    :preserve

      gem "enumerating"

  %p Adds a bunch of methods to Enumerable, including:

  %ul
    %li <code>selecting</code>
    %li <code>rejecting</code>
    %li <code>collecting</code>
    %li <code>uniqing</code>
    %li <code>taking</code>
    %li <code>dropping</code>

%section

  %h1 another example
  
  %pre
    :preserve

      # enumerate all users
      users = User.to_enum(:find_each)

      # where first and last names start with the same letter
      users = users.selecting do |u| 
        u.first_name[0] == u.last_name[0]
      end

      # grab their company (weeding out duplicates)
      companies = users.collecting(&:company).uniqing

      # resolve
      companies.to_a              #=> ["Disney"]

  %p pipes FTW!

%section

  %h1 combining Enumerables
  
  %pre
    :preserve

      array1 = [1, 2, 5]
      array2 = [3, 4, 6]

      Enumerating.<b>zipping</b>(array1, array2).to_a
      # => [[1, 3], [2, 4], [5, 6]]

      Enumerating.<b>concatenating</b>(array1, array2).to_a
      # => [1, 2, 5, 3, 4, 6]

      Enumerating.<b>merging</b>(array1, array2).to_a
      # => [1, 2, 3, 4, 5 ,6]

%section

  %h1 fancy schmancy

  %pre
    :preserve

      array1 = %w(a dd cccc)
      array2 = %w(eee bbbbb)

      Enumerating.<b>merging_by</b>(array1, array2) do |x| 
        x.<b>length</b>
      end.to_a
      # => %w(a dd eee cccc bbbbb)

      array3 = %w(Apple Banana Acorn Candle Zebra Butternut)
      array3.<b>uniqing_by</b> { |word| <b>word[0]</b> }.to_a
      # => %w(Apple Banana Candle Zebra)

%section

  %img(src="images/aggy.png")

%section

  %pre
    :preserve

      sources = [
        Post.recent.authored_by_friends_of(@user),
        Post.recent.on_interests_of(@user),
        UserFollowing.recent.by_friends_of(@user),
        TopicFollowing.recent.by_friends_of(@user)
      ]

      streams = sources.map do |scope| 
        scope.to_enum(:find_each)       # ... ish (wave hands)
      end
      
      merged_stream = Enumerating.merging_by(*streams, &:recency)

      entries = merged_stream.take(23)

      # with a bit of collecting and uniqing_by throw in ...
      
%section

  %h1 in summary

  %pre
    :preserve

      gem install enumerating

  %ul.big.sparse
    %li= raw_link("https://github.com/mdub/enumerating")
    %li= raw_link("http://twitter.com/woollyams")
    %li= raw_link("http://www.cogentconsulting.com.au/")
  
  %p For even more laziness, see:

  %ul.sparse
    %li= raw_link("https://github.com/harukizaemon/hamster")
