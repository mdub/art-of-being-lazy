---
layout: slideshow/_layout.html.haml
title: Enumerable, and the art of being lazy
...

- content_for[:head] = capture_haml do
  %link{:href => href("custom-styles.css"), :rel => "stylesheet"}/

%section.title

  %h1 Enumerable, and the art of being lazy

  %p Mike Williams, June 2011
  
%section

  %h1 a simple Enumerable

  %pre
    :preserve
    
      class SomeNumbers
  
        # declare one method
        
        def <b>each</b>
          yield 0
          yield 1
          yield 1
          yield 2
          yield 3
          yield 5
          yield 8
        end

        # mix in a bunch more
        
        include <b>Enumerable</b>
        
      end

%section

  %h1 woohoo free stuff!

  %pre
    :preserve

      numbers = SomeNumbers.new

      numbers.to_a              # => [0, 1, 1, 2, 3, 5, 8]

      numbers.take(5)           # => [0, 1, 1, 2, 3]
      numbers.drop(5)           # => [5, 8]

      numbers.max               # => 8

      numbers.collect do |x| 
        x * 2
      end                       # => [0, 2, 2, 4, 6, 10, 16]

      numbers.inject(&:+)       # => 20

%section

  %h1 cf. Unix pipes

  %table.center
    %tr
      %th Enumerable
      %th Unix command
    %tr
      %td
        %code select/find_all, reject, grep
      %td
        %code grep, grep -v
    %tr
      %td
        %code collect/map
      %td
        %code sed, awk, tr
    %tr
      %td
        %code sort, uniq
      %td
        %code sort, uniq
    %tr
      %td
        %code take, drop
      %td
        %code head, tail

  %pre
    :preserve

      cat messages.log | awk '{print $1}' | sort -u | wc -l

      messages.collect { |line| line.split[0] }.uniq.size

%section

  %h1 some nice properties
  
  %ul.big

    %li Small, simple operations

    %li Pre-tested

    %li Composable

%section

  %h1 observation:

  %p Some operations have to read <u>all</u> the input before producing output, e.g.

  %ul
    %li
      %code min
    %li
      %code max
    %li
      %code sort
    %li
      %code inject

  %p Some <u>could</u> start early, e.g.

  %ul
    %li
      %code select
    %li
      %code reject
    %li
      %code collect
    %li
      %code uniq

  %p (but they don't)
  
%section

  %h1 "big" problems

  %pre
    :preserve

      # an ActiveRecord example
      scope = Events.where("happened_at < ?", 1.week.ago)
      event_stream = scope.to_enum(:find_each)
    
      active_sources_last_week = event_stream   \
        .collect { |e| e.actor.name }           \
        .uniq                                   \
        .take(20)                         
      
%section

  %h1 solution: unroll the loops

  %pre
    :preserve

      # BEFORE
      
      active_sources_last_week = event_stream   \
        .collect { |e| e.actor.name }           \
        .uniq                                   \
        .take(20)                         

      # AFTER

      active_sources_last_week = []
      event_stream.each do |e|
        name = e.actor.name
        unless active_sources_last_week.member?(name)
          active_sources_last_week << name
        end
        break if active_sources_last_week.size == 20
      end

  %p Blah.
  
%section

  %h1 an infinite Enumerable

  %pre
    :preserve
    
      class FibonacciSequence
  
        def <b>each</b>
          a = 0
          b = 1
          loop do
            yield a
            a, b = b, a+b
          end
        end

        include <b>Enumerable</b>
        
      end

      irb> FibonacciSequence.new.each { |n| puts n }
      0
      1
      1
      2
      3
      5
      8
      13
      21
      ...

%section

  %h1 "infinite" problems

  %pre
    :preserve
      
      fib = FibonacciSequence.new
      
      fib.take(5)               # => [0, 1, 1, 2, 3]

      fib.drop(3).take(2)       # ... a long wait

      fib.select(&:even?)       # ... nada

      fib.collect do |x| 
        x * 2
      end                       # ... S.O.L.

%section

  %h1 case in point

  %pre
    :preserve

      # get the first five <u>even</u> Fibonacci numbers

      fib.select(&:even?).take(5)   # ... never returns

      # unrolled
      
      result = []
      
      fib.each do |n|
        result << n if n.even?
        break if result.size == 5
      end
      
      result                        # => [0, 2, 8, 34, 144]

%section

  %h1 getting more functional

  %pre
    :preserve

      # original
      
      fib.select(&:even?).take(5)
      
      # functional
      
      take(select(fib, &:even?), 5)

      # decorative
      
      Taker.new(Selector.new(fib, &:even?), 5)
    
%section

  %h1 decorative Enumerables

  %pre
    :preserve

      class <b>Selector</b>
  
        def initialize(source, &predicate)
          @source = source
          @predicate = predicate
        end
  
        def <b>each</b>
          @source.each do |value|
            yield value if @predicate.call(value)
          end
        end
  
        include Enumerable
  
      end

%section

  %h1 decorative sugar

  %pre
    :preserve

      module Enumerable
  
        def <b>selecting</b>(&predicate)
          Selector.new(self, &predicate)
        end
  
      end

      # fib.<strike>select</strike>(&:even?).take(5)
      
      fib.<b>selecting</b>(&:even?).take(5)  # => [0, 2, 8, 34, 144]

  %p Tah-dah!
