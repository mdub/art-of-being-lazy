<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <link href='slideshow/normalize.css' rel='stylesheet'>
    <link href='slideshow/styles.css' rel='stylesheet'>
    <title>Enumerable, and the art of being lazy</title>
    <link href='custom-styles.css' rel='stylesheet'>
  </head>
  <body>
    <article class='slideshow'>
      <header>
        <h1>Enumerable, and the art of being lazy</h1>
        <nav>
          <ul>
            <li>
              <button id='prev-btn' title='Previous slide'>Previous Slide</button>
            </li>
            <li><span id='slide-number'></span>/<span id='slide-total'></span></li>
            <li>
              <button id='next-btn' title='Next Slide'>Next Slide</button>
            </li>
          </ul>
        </nav>
      </header>
      <section class='title'>
        <h1>Enumerable, and the art of being lazy</h1>
        <p>Mike Williams, <strike>June 2011</strike> May 2016</p>
      </section>
      <section>
        <h1>a simple Enumerable</h1>
        <pre>class SomeNumbers&#x000A;&#x000A;  # declare one method&#x000A;&#x000A;  def <b>each</b>&#x000A;    yield 0&#x000A;    yield 1&#x000A;    yield 1&#x000A;    yield 2&#x000A;    yield 3&#x000A;    yield 5&#x000A;    yield 8&#x000A;  end&#x000A;&#x000A;  # mix in a bunch more&#x000A;&#x000A;  include <b>Enumerable</b>&#x000A;&#x000A;end&#x000A;</pre>
      </section>
      <section>
        <h1>woohoo free stuff!</h1>
        <pre>numbers = SomeNumbers.new&#x000A;&#x000A;numbers.to_a              # => [0, 1, 1, 2, 3, 5, 8]&#x000A;&#x000A;numbers.take(5)           # => [0, 1, 1, 2, 3]&#x000A;numbers.drop(5)           # => [5, 8]&#x000A;&#x000A;numbers.max               # => 8&#x000A;&#x000A;numbers.collect do |x|&#x000A;  x * 2&#x000A;end                       # => [0, 2, 2, 4, 6, 10, 16]&#x000A;&#x000A;numbers.inject(&:+)       # => 20&#x000A;</pre>
      </section>
      <section>
        <h1>
          #to_enum
          (1.9)
        </h1>
        <h2>turn any iterator into an Enumerator</h2>
        <pre>io = StringIO.new("abcdefghijklmnopqrstuvwxyz")&#x000A;&#x000A;io.<b>each_char</b> { |c| puts c }&#x000A;# prints "a", "b", etc.&#x000A;&#x000A;io.<b>to_enum</b>(:each_char).take(5)&#x000A;# => %w(a b c d e f g)&#x000A;</pre>
        <pre>array = %w(Juan Too Free)&#x000A;&#x000A;array.to_enum(:each_with_index).to_a&#x000A;# => [["Juan", 0], ["Too", 1], ["Free", 2]]&#x000A;</pre>
      </section>
      <section>
        <h1>cf. Unix pipes</h1>
        <table class='center'>
          <tr>
            <th>Enumerable</th>
            <th>Unix command</th>
          </tr>
          <tr>
            <td>
              <code>select, reject, grep</code>
            </td>
            <td>
              <code>grep, grep -v</code>
            </td>
          </tr>
          <tr>
            <td>
              <code>collect/map</code>
            </td>
            <td>
              <code>sed, awk, tr</code>
            </td>
          </tr>
          <tr>
            <td>
              <code>sort, uniq</code>
            </td>
            <td>
              <code>sort, uniq</code>
            </td>
          </tr>
          <tr>
            <td>
              <code>take, drop</code>
            </td>
            <td>
              <code>head, tail</code>
            </td>
          </tr>
        </table>
        <pre>cat messages.log | awk '{print $1}' | sort -u | wc -l&#x000A;&#x000A;messages.collect { |line| line.split[0] }.uniq.size&#x000A;</pre>
      </section>
      <section>
        <h2>similar</h2>
        <ul class='big sparse'>
          <li>small, simple operations</li>
          <li>pre-tested</li>
          <li>composable</li>
        </ul>
        <h2>but different</h2>
        <ul class='big sparse'>
          <li>not streamable</li>
          <li>not parallelisable</li>
        </ul>
      </section>
      <section>
        <h1>observation:</h1>
        <p>Some Enumerable operations have to read <u>all</u> the input before producing output, e.g.</p>
        <ul>
          <li>
            <code>min</code>
          </li>
          <li>
            <code>max</code>
          </li>
          <li>
            <code>sort</code>
          </li>
          <li>
            <code>inject</code>
          </li>
        </ul>
        <p>Some <u>could</u> start early, e.g.</p>
        <ul>
          <li>
            <code>select</code>
          </li>
          <li>
            <code>reject</code>
          </li>
          <li>
            <code>collect</code>
          </li>
          <li>
            <code>uniq</code>
          </li>
        </ul>
        <p>(but they don't)</p>
      </section>
      <section>
        <h1>an infinite Enumerable</h1>
        <pre>class FibonacciSequence&#x000A;&#x000A;  def <b>each</b>&#x000A;    a = 0&#x000A;    b = 1&#x000A;    loop do&#x000A;      yield a&#x000A;      a, b = b, a+b&#x000A;    end&#x000A;  end&#x000A;&#x000A;  include <b>Enumerable</b>&#x000A;&#x000A;end&#x000A;&#x000A;irb> FibonacciSequence.new.each { |n| puts n }&#x000A;0&#x000A;1&#x000A;1&#x000A;2&#x000A;3&#x000A;5&#x000A;8&#x000A;13&#x000A;21&#x000A;...&#x000A;</pre>
      </section>
      <section>
        <h1>"infinite" problems</h1>
        <pre>fib = FibonacciSequence.new&#x000A;&#x000A;fib.take(5)               # => [0, 1, 1, 2, 3]&#x000A;&#x000A;fib.drop(3).take(2)       # ... a long wait&#x000A;&#x000A;fib.select(&:even?)       # ... nada&#x000A;&#x000A;fib.collect do |x|&#x000A;  x * 2&#x000A;end                       # ... S.O.L.&#x000A;</pre>
      </section>
      <section>
        <h1>"big" problems</h1>
        <pre># an ActiveRecord example&#x000A;&#x000A;scope = Meetings.order_by("starts_at DESC")&#x000A;meetings = scope.<b>to_enum</b>(:find_each)&#x000A;&#x000A;recent_meeting_organisers = meetings      \&#x000A;  .collect { |e| e.organiser.name }       \&#x000A;  .uniq                                   \&#x000A;  .take(20)&#x000A;</pre>
        <p>Problems:</p>
        <ul class='sparse'>
          <li>generates (using collect, and uniq) a bunch of objects that are never used</li>
          <li>might require a lot of memory for temporary storage</li>
        </ul>
      </section>
      <section>
        <h1>solution: unroll the loops</h1>
        <pre># BEFORE&#x000A;&#x000A;recent_meeting_organisers = meetings      \&#x000A;  .collect { |e| e.organiser.name }       \&#x000A;  .uniq                                   \&#x000A;  .take(20)&#x000A;&#x000A;# AFTER&#x000A;&#x000A;recent_meeting_organisers = []&#x000A;meetings.each do |e|&#x000A;  name = e.organiser.name&#x000A;  unless recent_meeting_organisers.member?(name)&#x000A;    recent_meeting_organisers << name&#x000A;  end&#x000A;  break if recent_meeting_organisers.size == 20&#x000A;end&#x000A;</pre>
        <p>Blah. WTF!?</p>
      </section>
      <section>
        <h1>Fibonacci, unrolled</h1>
        <pre>fib = FibonacciSequence.new&#x000A;&#x000A;# get the first five <u>even</u> Fibonacci numbers&#x000A;&#x000A;fib.select(&:even?).take(5)   # ... never returns&#x000A;&#x000A;# unrolled&#x000A;&#x000A;result = []&#x000A;&#x000A;fib.each do |n|&#x000A;  result << n if n.even?&#x000A;  break if result.size == 5&#x000A;end&#x000A;&#x000A;result                        # => [0, 2, 8, 34, 144]&#x000A;</pre>
      </section>
      <section>
        <h1>Fibonacci, lazy</h1>
        <pre># get the first five <u>even</u> Fibonacci numbers&#x000A;&#x000A;fib.select(&:even?).take(5)   # ... never returns&#x000A;&#x000A;fib.<b>lazy</b>.select(&:even?).take(5).<b>to_a</b>&#x000A;                              # => [0, 2, 8, 34, 144]&#x000A;&#x000A;require 'lazily'&#x000A;&#x000A;fib.<b>lazily</b>.select(&:even?).take(5).to_a&#x000A;                              # => [0, 2, 8, 34, 144]&#x000A;</pre>
      </section>
      <section>
        <h1>breaking it down</h1>
        <h2>all sugary</h2>
        <pre>fib.lazily.select(&:even?).take(5)&#x000A;</pre>
        <h2>functional</h2>
        <pre>take(select(fib, &:even?), 5)&#x000A;</pre>
        <h2>decorative</h2>
        <pre>Taker.new(Selector.new(fib, &:even?), 5)&#x000A;</pre>
      </section>
      <section>
        <h2>lazy "select"</h2>
        <pre>class <b>Selector</b>&#x000A;&#x000A;  def initialize(source, <b>&predicate</b>)&#x000A;    @source = source&#x000A;    @predicate = predicate&#x000A;  end&#x000A;&#x000A;  def each&#x000A;    @source.each do |value|&#x000A;      <b>yield value if @predicate.call(value)</b>&#x000A;    end&#x000A;  end&#x000A;&#x000A;  include Enumerable&#x000A;&#x000A;end&#x000A;</pre>
      </section>
      <section>
        <h2>lazy "take"</h2>
        <pre>class <b>Taker</b>&#x000A;&#x000A;  def initialize(source, <b>n</b>)&#x000A;    @source = source&#x000A;    @n = n&#x000A;  end&#x000A;&#x000A;  def each&#x000A;    @source.each_with_index do |value, index|&#x000A;      <b>break if index >= @n&#x000A;      yield value</b>&#x000A;    end&#x000A;  end&#x000A;&#x000A;  include Enumerable&#x000A;&#x000A;end&#x000A;&#x000A;</pre>
      </section>
      <section>
        <h1>decorative sugar</h1>
        <pre>module Enumerable&#x000A;&#x000A;  def <b>lazy_select</b>(&predicate)&#x000A;    Selector.new(self, &predicate)&#x000A;  end&#x000A;&#x000A;  def <b>lazy_take</b>(n)&#x000A;    Taker.new(self, n)&#x000A;  end&#x000A;&#x000A;end&#x000A;&#x000A;fib.select(&:even?).take(5)     # ... never returns&#x000A;&#x000A;fib.<b>lazy_select</b>(&:even?).<b>lazy_take</b>(5)&#x000A;                                # => [0, 2, 8, 34, 144]&#x000A;</pre>
        <p>Tah-dah!</p>
      </section>
      <section>
        <h1>Lazily</h1>
        <pre>gem "lazily"&#x000A;</pre>
        <p>It applies layers of decorative laziness, e.g.</p>
        <pre>fib.lazily.select(&:even?).take(5)&#x000A;&#x000A;#=> #&lt;Lazily::Filter: take&#x000A;      #&lt;Lazily::Filter: select&#x000A;        #&lt;Lazily::Proxy:&#x000A;          #&lt;FibonacciSequence:0x007f8bc22ce868&gt;&gt;&gt;&gt;&#x000A;</pre>
        <h2>but wait, there's more!</h2>
      </section>
      <section>
        <h1>combining Enumerables</h1>
        <pre>numbers_a = [1, 2, 5]&#x000A;numbers_b = [3, 4, 6]&#x000A;&#x000A;Lazily.<b>zip</b>(numbers_a, numbers_b).to_a&#x000A;# => [[1, 3], [2, 4], [5, 6]]&#x000A;&#x000A;Lazily.<b>concat</b>(numbers_a, numbers_b).to_a&#x000A;# => [1, 2, 5, 3, 4, 6]&#x000A;&#x000A;Lazily.<b>merge</b>(numbers_a, numbers_b).to_a&#x000A;# => [1, 2, 3, 4, 5 ,6]&#x000A;&#x000A;words_1 = %w(a dd cccc)&#x000A;words_2 = %w(eee bbbbb)&#x000A;&#x000A;Lazily.<b>merge</b>(words_1, words_2, &:length).to_a&#x000A;# => %w(a dd eee cccc bbbbb)&#x000A;</pre>
      </section>
      <section>
        <h1>combine big/infinite things</h1>
        <pre><i># some source of content</i>&#x000A;sources = [&#x000A;  Post.recent.authored_by_friends_of(@user),&#x000A;  Post.recent.on_interests_of(@user),&#x000A;  UserFollowing.recent.by_friends_of(@user),&#x000A;  TopicFollowing.recent.by_friends_of(@user)&#x000A;]&#x000A;&#x000A;<i># stream each, most recent first</i>&#x000A;streams = sources.map do |source|&#x000A;  source.<b>to_enum(:find_each).lazily.uniq</b>&#x000A;end&#x000A;&#x000A;<i># merge into a single stream</i>&#x000A;merged_stream = <b>Lazily.merge</b>(*streams, &:recency)&#x000A;&#x000A;<i># grab a page's worth</i>&#x000A;page = merged_stream.<b>take</b>(23)&#x000A;</pre>
      </section>
      <section>
        <img src='images/aggy.png'>
      </section>
      <section>
        <h2>lazy dequeue</h2>
        <pre>q = Queue.new&#x000A;Thread.new do&#x000A;  q << 1&#x000A;  q << 2&#x000A;  q << 3&#x000A;  q << nil    # acts as "terminator"&#x000A;end&#x000A;&#x000A;Lazily.<b>dequeue(q)</b>.each do |item|&#x000A;  do_something_with(item)&#x000A;end&#x000A;&#x000A;Lazily.dequeue(q).take(2).to_a    # => [1,2]&#x000A;Lazily.dequeue(q).take(2).to_a    # => [3]&#x000A;</pre>
      </section>
      <section>
        <h2>lazy threads</h2>
        <pre>slow_double = ->(x) { sleep 1; x * 2 }&#x000A;&#x000A;Benchmark.realtime do&#x000A;  fib.lazily.map(&slow_double).take(100).to_a&#x000A;end&#x000A;#=> 100.14 seconds&#x000A;&#x000A;Benchmark.realtime do&#x000A;  fib.lazily.<b>in_threads(8</b>, &slow_double).take(100).to_a&#x000A;end&#x000A;#=> 13.02 seconds&#x000A;</pre>
      </section>
      <section>
        <h2>lazy threads involve some pre-work</h2>
        <pre>inputs = (1 .. 100)&#x000A;outputs = inputs.lazily.in_threads(3) do |i|&#x000A;  i * i&#x000A;end&#x000A;outputs.take(5).to_a    #=> [1, 4, 9, 16, 25]&#x000A;</pre>
        <p class='center-text'>
          <img src='images/anticipation.png'>
        </p>
      </section>
      <section>
        <h1>in summary</h1>
        <ul class='big sparse'>
          <li><a href="https://github.com/mdub/lazily">https://github.com/mdub/lazily</a></li>
          <li><a href="http://www.dogbiscuit.org/mdub">http://www.dogbiscuit.org/mdub</a></li>
          <li><a href="http://twitter.com/woollyams">http://twitter.com/woollyams</a></li>
        </ul>
        <h2 class='big center-text gap-before'>Go forth, be lazy!</h2>
      </section>
    </article>
    <script src='slideshow/jquery-1.5.2.min.js'></script>
    <script src='slideshow/htmlSlides.js'></script>
    <script>
      //Do our business when the DOM is ready for us
      $(function() {
      
        // One little option: hideToolbar (boolean; default = false)
        htmlSlides.init({ hideToolbar: true });
      
      });
    </script>
  </body>
</html>
